import base64
import hashlib
import hmac
import logging

from requests.auth import AuthBase
from requests.compat import urlparse
from requests.utils import quote, unquote

logger = logging.getLogger(__name__)


class HmacAuth(AuthBase):
    """
    Implements Hash-based Message Authentication Codes (HMAC). HMAC guarantees that:
      A) a message has been generated by a holder of the secret key; and,
      B) the message contents has not changed since the auth code was generated.
    Instances of HmacAuth are immutable and are therefore safe to use in multiple threads.
    """

    KEYSTORE = {}

    @classmethod
    def deregister_key(cls, key_id):
        del cls.KEYSTORE[key_id]

    @classmethod
    def register_key(cls, key_id, secret_key):
        cls.KEYSTORE[key_id] = secret_key

    def __init__(self, key_id, username=None):
        """
        :param key_id: identifier of the key registered with HmacAuth
        :param username: the ID of the user to send to the remote service
        :raises ValueError: if no matching key is found
        """
        secret_key = self.KEYSTORE.get(key_id, None)
        if not secret_key:
            raise ValueError("A secret key is required input for HMAC authentication")
        self._KEY_ID = key_id
        self._USERNAME = username
        self._SECRET_KEY = secret_key

    def __call__(self, request):
        """
        Overrides the empty base implementation to provide authentication for
        the provided request object.
        """

        # generate a signature for the message by hashing the request using the secret key
        sig = self._build_signature(request)

        # add message headers including the username (if present) and message
        # The version 1 spec of the HmacSignature class calls for the
        # Authorization HTTP header of the form:
        #   {Version}:{KeyId}:{UserId}:{Signature}
        header = ":".join(("1", self._KEY_ID, self._USERNAME or "", sig))
        request.headers["Authorization"] = header
        return request

    def _build_message(self, request):
        """
        Builds a string representation of the message contained in the request so it can be
        digested for HMAC generation
        """
        url = urlparse(request.url)

        # THe version 1 spec of the HmacSignature class calls for the message to be signed
        #   formatted as the following elements, each separated by a newline character:
        #   * UserId (same value as used in Authorization header)
        #   * HTTP Method (e.g. GET, POST)
        #   * HTTP Host (e.g. server.example.org)
        #   * Request path (e.g. /path/to/resource/)
        #   * SORTED query string, keyed by natural UTF8 byte-ordering of names
        #   * Request Body
        delimiter = "\n"
        body = ""
        if request.body:
            # Django request object has body as bytes; requests request object has body as str
            if isinstance(request.body, bytes):
                body = request.body.decode("utf-8")
            else:
                body = request.body
        msg = delimiter.join(
            (
                self._USERNAME or "",
                request.method,
                url.netloc,
                url.path,
                self._sort_parameters(url.query),
                body,
            )
        )
        return msg.encode("utf-8")

    def _build_signature(self, request):
        """
        Builds a signature for the provided request message based on the secret key.
        """
        key = base64.b64decode(self._SECRET_KEY)
        msg = self._build_message(request)
        digest = hmac.new(key, msg=msg, digestmod=hashlib.sha1).digest()
        sig = base64.b64encode(digest).decode()
        return sig

    def _sort_parameters(self, query):
        # split on ampersand
        params = query.split("&")
        # split each param into two-item lists of (key,value) and quote list entries
        params = [[quote(unquote(v)) for v in item.split("=", 1)] for item in params]
        # sort based on key portion
        params = sorted(params, key=lambda p: p[0])
        # join back together on ampersand
        return "&".join(map(lambda p: "=".join(p), params))

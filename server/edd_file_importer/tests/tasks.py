# coding: utf-8

import os
from unittest.mock import call, patch

from django.contrib.auth import get_user_model
from django.test import override_settings

from edd.tests import TestCase
from main import models as edd_models

from .. import tasks
from ..models import Import
from .test_utils import MsgContent, WSTestMixin, clear_import_cache

# TODO: for final pass/fail disposition, also check for menu notifications:
#  patch("edd_file_importer.utilities.NotificationWsBroker")

# TODO: test admin emails

# TODO: add tests that also cover complete_import_task(), which at the time of writing can be
# quickly tested via a combination of existing manual and unit tests.  Include single-request
# submit workflow, including resolve/parse warnings available in the final status message


User = get_user_model()

_TEST_FILES_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "files")
_GENERIC_FILES_DIR = os.path.join(_TEST_FILES_DIR, "generic_import")
_SKYLINE_FILES_DIR = os.path.join(_TEST_FILES_DIR, "skyline")


@override_settings(MEDIA_ROOT=_GENERIC_FILES_DIR)
class ErrPropagationTests(WSTestMixin, TestCase):
    """
    Tests that errors from an incorrectly-formatted file propagate as expected through
    process_import_file(), and have the desired high-level outcome.  This is a representative
    test for errors thrown in the body of process_import_file.  We probably don't need to test
    error propagation separately at this level for each different error condition.
    """

    fixtures = ["edd_file_importer/generic_fba_imports"]

    @classmethod
    def setUpTestData(cls):
        super().setUpTestData()
        cls.write_user = User.objects.get(username="study.writer.user")

    def _file_path(self, filename):
        return os.path.join("generic_import", filename)

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_submit_failed_parse_err_workflow(self):
        """
        Tests that process_import_file() fails an import and doesn't call process_import_file()
        when parsing errors occur.
        """
        import_pk = 16

        with patch("edd_file_importer.tasks.complete_import_task") as MockCompleteTask:
            complete_import_task = MockCompleteTask.return_value

            # run the task synchronously to verify expected user notifications
            tasks.process_import_file(
                import_pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # verify final import status ends is FAILED
            import_ = Import.objects.get(pk=import_pk)
            self.assertEqual(import_.status, Import.Status.FAILED)

            # verify complete task was not called either synchronously or asynchronously following
            # failure
            complete_import_task.assert_not_called()
            complete_import_task.delay.assert_not_called()

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_submit_failed_parse_err_notifications(self):
        """
        Tests that ImportResolver sends a WS notification and email when a submit fails due to a
        parse error
        """
        payload_path = os.path.join(
            "generic_import", "generic_import_parse_errs.xlsx.ws-failed-payload.json"
        )

        # mock import-specific WS notifications so we can verify WS notifications
        # generated by the task
        with patch("edd_file_importer.tasks.ImportWsBroker") as MockImportWs:
            ws = MockImportWs.return_value

            # run the task synchronously to verify expected user notifications
            tasks.process_import_file(
                16,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # test that resolver initiates the WS notification indicating FAILED state
            ws.notify.assert_called_once_with(
                'Your import for file "generic_import_parse_errs.xlsx" failed. The problem was: '
                '"Invalid file"',
                tags=["import-status-update"],
                payload=MsgContent.load_payload_file(payload_path),
            )


@override_settings(MEDIA_ROOT=_GENERIC_FILES_DIR)
class ProcessingSuccessWorkflowTests(WSTestMixin, TestCase):
    """
    Tests basic functionality of the process_import_file() for successfully resolving import file
    data against a study
    """

    fixtures = ["edd_file_importer/generic_fba_imports"]

    @classmethod
    def setUpTestData(cls):
        super().setUpTestData()
        cls.write_user = User.objects.get(username="study.writer.user")

    def _file_path(self, filename):
        return os.path.join("generic_import", filename)

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_ready_workflow_no_submit(self):
        """
        Tests that successful processing of an import by process_import_file() leaves the import
        READY to execute, but does not process it if client did not request that.  This workflow is
        important to import step 3, where user will want to verify that inputs for
        interpreting the file were correct, but not necessarily process the import until hitting
        "go".
        """
        import_pk = 13
        import_ = Import.objects.get(pk=import_pk)

        with patch("edd_file_importer.tasks.complete_import_task") as MockCompleteTask:
            complete_import_task = MockCompleteTask.return_value

            # run the task synchronously to verify expected user notifications
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=None,
                initial_upload=True,
            )

            # verify final import status ends is READY
            import_ = Import.objects.get(pk=import_.pk)
            self.assertEqual(import_.status, Import.Status.READY)

            # verify complete task was not called either synchronously or asynchronously
            # since we didn't request a submit
            complete_import_task.assert_not_called()
            complete_import_task.delay.assert_not_called()

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_ready_notification_no_submit(self):
        """
        Tests that ImportResolver sends a WS notification when its work is done and the import
        is ready to execute.  This will be important for confirming in the UI that user entries
        for interpreting the file are correct, but before the import is finally executed.
        """
        import_pk = 13
        import_ = Import.objects.get(pk=import_pk)
        ws_payload_path = self._file_path("FBA-OD-generic.xlsx.ws-ready-payload.json")

        # mock import-specific WS notifications so we can verify WS notifications
        # generated by the task
        with patch("edd_file_importer.tasks.ImportWsBroker") as MockImportWs:
            ws = MockImportWs.return_value

            # run the task synchronously to verify expected user notifications
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=None,
                initial_upload=True,
            )

            # test that resolver initiates the WS notification indicating READY state
            ws.notify.assert_called_once_with(
                'Your file "FBA-OD-generic.xlsx" is ready to import',
                tags=["import-status-update"],
                payload=MsgContent.load_payload_file(ws_payload_path),
            )

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_submit_success_workflow(self):
        """
        Tests that process_import_file() has the correct workflow and calls complete_import_task()
        synchronously when user request is to submit.  This test is very similar to
        rest_ready_workflow_no_submit(), only client request is to submit the import.

        This workflow is important for propagating warning output from the resolution step to the
        final user notification that the import was completed.
        """
        import_pk = 13
        import_ = Import.objects.get(pk=import_pk)

        with patch(
            "edd_file_importer.tasks.complete_import_task"
        ) as complete_import_task:

            # run the task synchronously to verify expected outcomes
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # verify final import status ends is SUBMITTED
            import_ = Import.objects.get(pk=import_.pk)
            self.assertEqual(import_.status, Import.Status.SUBMITTED)

            # verify complete task was not called either synchronously or asynchronously
            # since user didn't request a submit
            complete_import_task.assert_called_once()
            complete_import_task.delay.assert_not_called()

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_submit_success_notifications(self):
        """
        Tests that process_import_file() produces the expected WS notifications as an import
        progresses to the SUBMITTED state.
        """
        import_pk = 13
        import_ = Import.objects.get(pk=import_pk)
        ready_payload_path = self._file_path(
            "FBA-OD-generic.xlsx.ws-ready-payload.json"
        )
        submitted_payload_path = self._file_path(
            "FBA-OD-generic.xlsx.ws-submitted-payload.json"
        )

        # mock complete_import_task so it doesn't execute
        with patch("edd_file_importer.tasks.complete_import_task"):
            # mock import-specific WS notifications so we can verify them
            with patch("edd_file_importer.tasks.ImportWsBroker") as MockImportWs:
                ws = MockImportWs.return_value

                # run the task synchronously to verify expected user notifications
                tasks.process_import_file(
                    import_.pk,
                    self.write_user.pk,
                    requested_status=Import.Status.SUBMITTED,
                    initial_upload=True,
                )

                # test that resolver initiates the WS notification indicating SUBMITTED state
                ws.notify.assert_has_calls(
                    [
                        call(
                            'Your file "FBA-OD-generic.xlsx" is ready to import',
                            tags=["import-status-update"],
                            payload=MsgContent.load_payload_file(ready_payload_path),
                        ),
                        call(
                            'Your import for file "FBA-OD-generic.xlsx" is submitted',
                            tags=["import-status-update"],
                            payload=MsgContent.load_payload_file(
                                submitted_payload_path
                            ),
                        ),
                    ]
                )
                self.assertEqual(len(ws.notify.call_args_list), 2)


@override_settings(MEDIA_ROOT=_GENERIC_FILES_DIR)
class OverwriteTests(TestCase):
    """
    Tests basic high-level functionality of the process_import_file() task that's
    more-or-less unique to the task itself rather than it's constituent parts
    ImportParseExecutor and ImportResolver: transitioning the import through the expected
    workflow, and providing client WS notifications as the processing progresses (or fails).
    """

    fixtures = [
        "edd_file_importer/generic_fba_imports",
        "edd_file_importer/generic_fba_imported",
    ]

    @classmethod
    def setUpTestData(cls):
        super().setUpTestData()
        cls.write_user = User.objects.get(username="study.writer.user")

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_resolved_overwrite_ws_notification(self):
        """
        Tests WS notifications for the overwrite detection workflow.  This is a special case where
        the import progresses to resolved, but needs additional user input in the form of a
        confirmation that overwriting study data is ok.  Rather than failing, the import
        progresses to RESOLVED and stays there.
        """
        # get the import in its initial CREATED state
        import_ = Import.objects.get(pk=13)

        # mock import-specific WS notifications so we can verify WS notifications
        # generated by the task
        with patch("edd_file_importer.tasks.ImportWsBroker") as MockImportWs:
            ws = MockImportWs.return_value

            # run the task synchronously to verify expected user notifications
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # test that resolver initiates the WS notification indicating RESOLVED state
            ws_payload_path = self._file_path(
                "FBA-OD-generic.xslx.ws-overwrite-payload.json"
            )
            ws.notify.assert_called_once_with(
                "Acknowledge warnings before your import can continue for file "
                '"FBA-OD-generic.xlsx"',
                tags=["import-status-update"],
                payload=MsgContent.load_payload_file(ws_payload_path),
            )

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_resolved_overwrite_workflow(self):
        """
        Tests the overwrite detection workflow.  This is a special case where the import
        progresses to resolved, but needs additional user input in the form of a confirmation
        that overwriting study data is ok.  Rather than failing, the import progresses to
        RESOLVED and stays there, even though the client request was to submit.  This is a common
        use case for the front end.
        """
        # get the import in its initial CREATED state
        import_ = Import.objects.get(pk=13)

        # mock complete_import_task() so we can verify it isn't called
        with patch("edd_file_importer.tasks.complete_import_task") as MockCompleteTask:
            complete_import_task = MockCompleteTask.return_value

            # run the task synchronously to verify expected user notifications
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # verify final import status ends is RESOLVED
            import_ = Import.objects.get(pk=import_.pk)
            self.assertEqual(import_.status, Import.Status.RESOLVED)

            # verify complete task was not called either synchronously or asynchronously
            complete_import_task.assert_not_called()
            complete_import_task.delay.assert_not_called()

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EMAIL_SUBJECT_PREFIX="[EDD]: ")
    def test_resolved_overwrite_email_notification(self):
        import_ = Import.objects.get(pk=13)

        # set the flag for email notification
        import_.email_when_complete = True
        import_.save()

        # mock send_mail so we can verify that an email gets sent.  Note that even when
        # process_import_file() is run synchronously here, Celery seems to interfere with the
        # normal django email testing via mail.outbox.
        with patch("django.core.mail.send_mail") as send_mail:

            # run the task synchronously and verify it attempted to send the user notification.
            # a request for SUBMITTED status is needed to generate the email
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )
            send_mail.assert_called_once()

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_resolved_duplicate_workflow(self):
        """
        Tests the duplicate detection workflow.  This is a special case where the import
        progresses to resolved, but needs additional user input in the form of a confirmation that
        duplicating study data is ok.  Rather than failing, the import progresses to RESOLVED
        and stays there, even though the client request was to submit.  This is a common use case
        for the front end.
        """
        # rename both assays from the fixture so that assay name checks totally fail and the
        # import drops back to matching against line names
        edd_models.Assay.objects.filter(study_id=10, name="arcA").update(
            name="arc_original"
        )
        edd_models.Assay.objects.filter(study_id=10, name="BW1").update(
            name="BW1_original"
        )

        # get the import in its initial CREATED state
        import_ = Import.objects.get(pk=13)

        with patch("edd_file_importer.tasks.complete_import_task") as MockCompleteTask:
            complete_import_task = MockCompleteTask.return_value

            # run the task synchronously and verify that even when client requests submitted
            # status, e.g. the normal case for the front end, the
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # verify final import status ends is RESOLVED
            import_ = Import.objects.get(pk=import_.pk)
            self.assertEqual(import_.status, Import.Status.RESOLVED)

            # verify complete task was not called either synchronously or asynchronously
            complete_import_task.assert_not_called()
            complete_import_task.delay.assert_not_called()

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EDD_IMPORT_PAGE_SIZE=14, EDD_IMPORT_CACHE_LENGTH=5)
    def test_resolved_duplicate_ws_notification(self):
        """
        Tests the duplicate detection workflow in process_import_file().  This is a special case
        where the import gets to resolved, but needs additional user input in the form of a
        confirmation that duplicating study data is ok.  Rather than failing, the import
        progresses to RESOLVED and stays there.  This is a common use case for the front end.
        """
        # rename both assays from the fixture so that assay name checks totally fail and the
        # import drops back to matching against line names
        edd_models.Assay.objects.filter(study_id=10, name="arcA").update(
            name="arc_original"
        )
        edd_models.Assay.objects.filter(study_id=10, name="BW1").update(
            name="BW1_original"
        )

        # get the import in its initial CREATED state
        import_ = Import.objects.get(pk=13)

        # mock import-specific WS notifications so we can verify WS notifications
        # generated by the resolver
        with patch("edd_file_importer.tasks.ImportWsBroker") as MockImportWs:
            ws = MockImportWs.return_value

            # run the task synchronously and verify it attempted to send the user notification
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )

            # test that resolver initiates the WS notification indicating READY state
            ws_payload_path = self._file_path(
                "FBA-OD-generic.xlsx.ws-duplicate-payload.json"
            )
            ws.notify.assert_called_once_with(
                "Acknowledge warnings before your import can continue for file "
                '"FBA-OD-generic.xlsx"',
                tags=["import-status-update"],
                payload=MsgContent.load_payload_file(ws_payload_path),
            )

    @clear_import_cache(import_uuid="ec2e3a30-3f35-4219-88a8-cf78fb100a98")
    @override_settings(EMAIL_SUBJECT_PREFIX="[EDD]: ")
    def test_resolved_duplicate_email_notification(self):
        """
        Tests that if the user requested an email notification re: disposition of the import,
        they get an email regarding need for additional input before it can be completed
        """
        # rename both assays from the fixture so that assay name checks fail and the import
        # drops back to matching against line names
        edd_models.Assay.objects.filter(study_id=10, name="arcA").update(
            name="arc_original"
        )
        edd_models.Assay.objects.filter(study_id=10, name="BW1").update(
            name="BW1_original"
        )

        import_ = Import.objects.get(pk=13)

        # set the flag for email notification
        import_.email_when_complete = True
        import_.save()

        # mock send_mail so we can verify that an email gets sent.  Note that even when
        # process_import_file() is run synchronously here, Celery seems to interfere with the
        # normal django email testing via mail.outbox.
        with patch("django.core.mail.send_mail") as send_mail:
            tasks.process_import_file(
                import_.pk,
                self.write_user.pk,
                requested_status=Import.Status.SUBMITTED,
                initial_upload=True,
            )
            send_mail.assert_called_once()

    def _file_path(self, filename):
        return os.path.join("generic_import", filename)
